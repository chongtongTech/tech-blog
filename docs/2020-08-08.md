---
title: 交叉编译docker镜像
description: 通过buildx可以使用Dockerfile构建多平台镜像
date:   2020-08-08 17:39:00
---

# {{ $frontmatter.title }}

<span style="color: red;">结论：<br>
通过 buildx 可以使用 Dockerfile 构建多平台镜像；<br>
但是针对 java 工程的 maven Jib 插件，可以直接使用其中高版本的实验功能“<em>platforms</em>”构建多平台镜像，不需要修改 docker 配置。<br>
可使用 buildx 验证或 docker inspect 查看镜像的编译平台
</span>


[交叉编译教程](https://blog.csdn.net/alex_yangchuansheng/article/details/103146303)<br>
模拟目标硬件的用户空间<br>
binfmt_misc<br>
程序运行时动态翻译二进制文件<br>

### 使用交叉编译器
**构建多平台 Docker 镜像**
Docker 19.03 引入的插件 buildx，构建多平台 Docker 镜像<br>
利用 BuildKit的全部功能扩展了 `docker build` 的功能<br>

```bash
#启用 buildx 插件
#Docker 版本不低于 19.03

#设置环境变量（开启实验特性）
vi /etc/profile
export DOCKER_CLI_EXPERIMENTAL=enabled
source /etc/profile

#验证是否开启
docker buildx version
#github.com/docker/buildx v0.3.1-tp-docker 6db68d029599c6710a32aa7adcba8e5a344795a7

#启用 binfmt_misc
docker run --rm --privileged docker/binfmt:66f9012c56a8316f9244ffd7622d7c21c1f6f28d

#验证是 binfmt_misc 否开启
ls -al /proc/sys/fs/binfmt_misc/
cat /proc/sys/fs/binfmt_misc/qemu-aarch64
```


### 从默认的构建器切换到多平台构建器
```
#创建一个新的构建器
docker buildx create --use --name mybuilder

#启动构建器
docker buildx inspect mybuilder --bootstrap

#查看当前构建器
docker buildx ls

#使用Dockerfile构建本地镜像
docker buildx build -t hello:amd64 --platform=linux/amd64 -o type=docker .
docker buildx build -t hello:arm64 --platform=linux/arm64 -o type=docker .

#运行镜像
#后台运行
docker run --name hello-amd64 -d hello:amd64
docker run --name hello-arm64 -d hello:arm64
```
Dockerfile：
```dockerfile
#amd64
#FROM adoptopenjdk/openjdk8-openj9:alpine-slim

#arm64
FROM adoptopenjdk/openjdk8-openj9:aarch64-ubi-minimal-jre8u-nightly
EXPOSE 8080
VOLUME /tmp
ADD hello.jar /app.jar
ENV JAVA_OPTS="-Dfile.encoding=UTF8  -Duser.timezone=GMT+08"
ENTRYPOINT [ "sh", "-c", "java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar" ]
```




### maven jib插件构建多平台镜像
[jib多平台构建参数](https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin#quickstart)

[jib多平台构建具体操作](https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image)
<br>若只编译多平台镜像，则此方法无需修改docker相关配置

#### 获取多平台的基础镜像
[docker官网](https://hub.docker.com/search)搜索可用的多平台镜像，Tags的OS/ARCH会显示具体支持平台
如 `openjdk:8-jdk-alpine`


远程镜像查看命令（需要[启用Docker CLI](https://docs.docker.com/engine/reference/commandline/cli/#experimental-features)实验特性，之前在启用buildx时已经设置相关环境变量）：<br>
`docker manifest inspect openjdk:8-jdk-alpine`


结果：
![QQ截图20210321185545.png](/img/20210808-1.PNG)
#### 修改jib插件配置
实验特性：`platforms` <br>
`from.platforms.platform` ：配置基础映像的平台以从清单清单中进行选择。<br>

| **Property** | **Type** | **Default** | **Description** |
| --- | --- | --- | --- |
| architecture | string | amd64 | The architecture of a base image to select from a manifest list. |
| os | string | linux | The OS of a base image to select from a manifest list. |

pom.xml
```xml
<jib-maven-plugin.version>2.8.0</jib-maven-plugin.version>
<plugin>
    <groupId>com.google.cloud.tools</groupId>
    <artifactId>jib-maven-plugin</artifactId>
    <version>${jib-maven-plugin.version}</version>
    <configuration>
        <from>
            <image>${docker.image.from}</image>
            <platforms>
                <platform>
                    <architecture>amd64</architecture>
                    <os>linux</os>
                </platform>
                <platform>
                    <architecture>arm64</architecture>
                    <os>linux</os>
                </platform>
            </platforms>
        </from>
        ...
     </configuration>
</plugin>
```


#### 运行maven构建命令
多平台构建只能运行`jib:build`  推送到镜像仓库


`mvn clean package jib:build`
构建结果：
![QQ截图20210321020229.png](/img/20210808-2.PNG)
验证命令：`docker buildx imagetools inspect 127.0.0.1:5000/demo/snapshots/hello`


![QQ截图20210321020411.png](/img/20210808-3.PNG)




可以通过 `docker pull 127.0.0.1:5000/demo/snapshots/hello` 拉取刚刚创建的镜像了，Docker 将会根据你的 CPU 架构拉取匹配的镜像

#### 启用本地镜像仓库
若没有私有的远程仓库，则可以启用本地仓库
```
#启用本地镜像仓库
docker pull registry

#启动
docker run -itd -v /root/docker-registry:/data/registry --restart=always --name docker-registry -p 5000:5000 registry:latest

#本地镜像打tag
docker tag a3562aa0b991 127.0.0.1:5000/openjdk:8-jdk-alpine

#推送到本地镜像库
docker push 127.0.0.1:5000/openjdk:8-jdk-alpine
```


### 通过命令行指定jib编译平台
#### pom文件设置
```xml
<properties>
        <docker.repostory>xxx</docker.repostory>
        <docker.registry.name>xxx</docker.registry.name>
        <docker.image.from>openjdk:8-jdk-alpine</docker.image.from>
        <docker.image.to>xxx</docker.image.to>
        <docker.platform.arch>amd64</docker.platform.arch>
</properties>
<build>
  <plugin>
  	<groupId>com.google.cloud.tools</groupId>
		<artifactId>jib-maven-plugin</artifactId>
		<version>${jib-maven-plugin.version}</version>
		<configuration>
			<from>
				<image>${docker.image.from}</image>
				<platforms>
					<platform>
						<architecture>${docker.platform.arch}</architecture>
						<os>linux</os>
					</platform>
				</platforms>
			</from>
			<to>
				<image>
					${docker.repostory}/${docker.registry.name}/${docker.image.to}/${project.artifactId}
				</image>
			</to>
			...
		</configuration>
 	</plugin>
</build>
```
#### arm64平台编译
`mvn clean package jib:build -Ddocker.platform.arch=arm64 -Djib.to.tags=arm64`


拉取生成的镜像后，使用docker inspect 查看结果：<br>
`docker inspect 127.0.0.1:5000/demo/snapshots/hello:arm64`<br>
![QQ截图20210321184400.png](/img/20210808-4.PNG)
#### 

#### x86-64平台编译
`mvn clean package jib:build -Ddocker.platform.arch=amd64 -Djib.to.tags=amd64`


拉取生成的镜像后，使用docker inspect 查看结果：<br>
`docker inspect 127.0.0.1:5000/demo/snapshots/hello:amd64`<br>
![QQ截图20210321184522.png](/img/20210808-5.PNG)
### 参考文档：
[buildx教程](https://www.bookstack.cn/read/docker_practice-1.2.0/buildx-multi-arch-images.md)<br>
[buildx官方文档](https://docs.docker.com/buildx/working-with-buildx/)<br>
[jib操作教程1](https://blog.csdn.net/boling_cavalry/article/details/100179709)<br>
[jib操作教程2](https://jitwxs.blog.csdn.net/article/details/103606999)<br>
